---
title: Conference App
slug: /guides/conference-app
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide shows how to build a minimal Google Meet-style conference app using Next.js and dTelecom's React components. The complete app is about 80 lines of code.

:::tip Full example — created 100% by AI agent
See [dTelecom Meet](https://github.com/dTelecom/dtelecom-meet) for a complete app with host controls, chat, pre-join preview, webhooks, and one-click Vercel deploy. **[Live Demo](https://dtelecom-meet-demo.vercel.app/)**
:::

## Prerequisites

- Node.js 18+
- API keys from [cloud.dtelecom.org](https://cloud.dtelecom.org) (see [Getting Started](/guides/getting-started))

## Project setup

```bash
npx create-next-app@latest my-conference --app --typescript
cd my-conference
npm install @dtelecom/server-sdk-js @dtelecom/livekit-client @dtelecom/components-react @dtelecom/components-styles
```

:::note
Next.js 16+ may ask about the **React Compiler** during project creation. Select **No** for now — the React Compiler is experimental and may cause issues with some dTelecom components.
:::

Create `.env.local`:

```bash
API_KEY=<your-api-key>
API_SECRET=<your-api-secret>
SOLANA_CONTRACT_ADDRESS=E2FcHsC9STeB6FEtxBKGAwMTX7cbfYMyjSHKs4QbBAmh
SOLANA_NETWORK_HOST_HTTP=https://api.mainnet-beta.solana.com
SOLANA_REGISTRY_AUTHORITY=6KVRs6Yr2oYzddepFdtWrFmVq8sgELcXzbUy7apwuQX4
```

## Server: API route for joining rooms

This route creates a token and resolves the WebSocket URL for the SFU node.

```typescript title="app/api/join/route.ts"
import { AccessToken } from '@dtelecom/server-sdk-js';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(req: NextRequest) {
  const { room, identity } = await req.json();

  if (!room || !identity) {
    return NextResponse.json({ error: 'room and identity are required' }, { status: 400 });
  }

  const at = new AccessToken(
    process.env.API_KEY!,
    process.env.API_SECRET!,
    { identity, name: identity }
  );
  at.addGrant({
    roomJoin: true,
    room,
    canPublish: true,
    canSubscribe: true,
  });

  const token = at.toJwt();
  const clientIp = (req.headers.get('x-forwarded-for') ?? '127.0.0.1').split(',')[0].trim();
  const wsUrl = await at.getWsUrl(clientIp);

  return NextResponse.json({ token, wsUrl });
}
```

## Client: conference page

```tsx title="app/page.tsx"
'use client';
import { LiveKitRoom, VideoConference } from '@dtelecom/components-react';
import '@dtelecom/components-styles';
import { useState } from 'react';

export default function Home() {
  const [room, setRoom] = useState('');
  const [identity, setIdentity] = useState('');
  const [token, setToken] = useState('');
  const [wsUrl, setWsUrl] = useState('');

  async function joinRoom() {
    const res = await fetch('/api/join', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ room, identity }),
    });
    const data = await res.json();
    setToken(data.token);
    setWsUrl(data.wsUrl);
  }

  function leaveRoom() {
    setToken('');
    setWsUrl('');
  }

  // Show join form if not connected
  if (!token || !wsUrl) {
    return (
      <div style={{ padding: 40 }}>
        <h1>Join a Conference</h1>
        <div>
          <input
            placeholder="Room name"
            value={room}
            onChange={(e) => setRoom(e.target.value)}
          />
          <input
            placeholder="Your name"
            value={identity}
            onChange={(e) => setIdentity(e.target.value)}
          />
          <button onClick={joinRoom} disabled={!room || !identity}>
            Join
          </button>
        </div>
      </div>
    );
  }

  // Show video conference when connected
  return (
    <LiveKitRoom
      token={token}
      serverUrl={wsUrl}
      connect={true}
      onDisconnected={leaveRoom}
    >
      <VideoConference />
    </LiveKitRoom>
  );
}
```

## Pre-join page

For a better user experience, add a pre-join page where users can preview their camera and microphone before entering the room. Use the `<PreJoin>` component:

```tsx title="app/prejoin/page.tsx"
'use client';
import { PreJoin, LocalUserChoices } from '@dtelecom/components-react';
import '@dtelecom/components-styles';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function PreJoinPage() {
  const router = useRouter();
  const [error, setError] = useState('');

  async function handleSubmit(choices: LocalUserChoices) {
    try {
      const res = await fetch('/api/join', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ room: 'my-room', identity: choices.username }),
      });
      const data = await res.json();
      // Pass token and settings to the room page
      const params = new URLSearchParams({
        token: data.token,
        wsUrl: data.wsUrl,
        audioEnabled: String(choices.audioEnabled),
        videoEnabled: String(choices.videoEnabled),
      });
      router.push(`/room?${params}`);
    } catch (e: any) {
      setError(e.message);
    }
  }

  return (
    <div style={{ height: '100vh' }}>
      {error && <div style={{ color: 'red', padding: 16 }}>{error}</div>}
      <PreJoin
        onSubmit={handleSubmit}
        onError={(err) => setError(err.message)}
        defaults={{ username: '', videoEnabled: true, audioEnabled: true }}
      />
    </div>
  );
}
```

The `<PreJoin>` component provides:
- Camera and microphone preview
- Device selection dropdowns
- Username input
- `LocalUserChoices` returned on submit: `{ username, videoEnabled, audioEnabled, videoDeviceId, audioDeviceId }`

**Camera-off placeholder:** When a participant's camera is off, `<ParticipantTile>` automatically shows a placeholder with the participant's name — no extra code needed.

## How it works

1. The user enters a room name and their display name, then clicks **Join**
2. The client POSTs to `/api/join` which creates an Ed25519-signed JWT and queries Solana for the best SFU node
3. The client receives `{ token, wsUrl }` and renders `<LiveKitRoom>` which connects via WebSocket
4. `<VideoConference />` provides a complete UI with video tiles, mic/camera toggles, screen sharing, and a leave button
5. When the user disconnects, `onDisconnected` resets state back to the join form

## Running the app

```bash
npm run dev
```

Open two browser tabs at `http://localhost:3000`. Enter the same room name with different identities to start a video call.

## Customizing the UI

`<VideoConference />` is a pre-built layout. For more control, compose individual components:

```tsx
import {
  LiveKitRoom,
  GridLayout,
  ParticipantTile,
  useTracks,
  RoomAudioRenderer,
  ControlBar,
} from '@dtelecom/components-react';
import { Track } from '@dtelecom/livekit-client';

function MyConference() {
  const tracks = useTracks(
    [
      { source: Track.Source.Camera, withPlaceholder: true },
      { source: Track.Source.ScreenShare, withPlaceholder: false },
    ],
    { onlySubscribed: false }
  );

  return (
    <div style={{ height: '100vh' }}>
      <GridLayout tracks={tracks}>
        <ParticipantTile />
      </GridLayout>
      <RoomAudioRenderer />
      <ControlBar />
    </div>
  );
}
```

### ControlBar props

`<ControlBar>` accepts these props for customization:

| Prop | Type | Description |
|:-----|:-----|:------------|
| `variation` | `"minimal" \| "verbose" \| "textOnly"` | Display style. `"minimal"` shows icons only, `"verbose"` adds labels, `"textOnly"` hides icons. |
| `controls` | `object` | Toggle which buttons appear: `{ microphone?: boolean, camera?: boolean, chat?: boolean, screenShare?: boolean, leave?: boolean }` |

```tsx
<ControlBar variation="verbose" controls={{ chat: false, screenShare: false }} />
```

### The `data-lk-theme` attribute

`<LiveKitRoom>` automatically sets the `data-lk-theme="default"` attribute on its container, which activates the dTelecom component styles. Components **outside** `<LiveKitRoom>` (like `<PreJoin>`) don't get this automatically — wrap them manually:

```tsx
<div data-lk-theme="default">
  <PreJoin onSubmit={handleSubmit} />
</div>
```

Available themes: `"default"` (dark), `"huddle"` (compact).

### CSS custom properties

The dTelecom component styles use CSS custom properties (variables) that you can override for theming:

```css
[data-lk-theme="default"] {
  --lk-bg: #1a1a2e;          /* primary background */
  --lk-bg2: #16213e;         /* secondary background (panels, cards) */
  --lk-fg: #e0e0e0;          /* foreground/text color */
  --lk-accent-bg: #0f3460;   /* accent background (active buttons) */
  --lk-danger: #e94560;      /* danger/destructive actions */
  --lk-border-radius: 8px;   /* global border radius */
  --lk-grid-gap: 8px;        /* gap between video tiles */
  --lk-control-bar-height: 56px; /* height of bottom control bar */
}
```

## Adding chat

Add in-room chat with the `<Chat>` component. Make sure the token grant includes `canPublishData: true`:

```typescript
// In your API route, add canPublishData to the grant:
at.addGrant({
  roomJoin: true,
  room,
  canPublish: true,
  canSubscribe: true,
  canPublishData: true, // required for chat
});
```

```tsx title="ChatPanel.tsx"
import { Chat } from '@dtelecom/components-react';

// Inside a <LiveKitRoom> component:
function ChatPanel() {
  return (
    <div style={{ width: 320, height: '100%' }}>
      <Chat />
    </div>
  );
}
```

For a custom chat UI, use the `useChat` hook — see [Working with Data](/guides/room/data#built-in-chat).

## Host controls

To let the room creator kick or mute participants, use the role-in-metadata pattern:

1. **Set role in token** — pass `metadata: JSON.stringify({ role: 'host' })` when creating the token (see [Access Tokens](/guides/access-tokens#role-based-metadata-example))
2. **Read role on client** — use `useLocalParticipant()` to check if the current user is a host
3. **Verify on backend** — your API route checks the caller's metadata before calling `RoomServiceClient.removeParticipant()` or `.mutePublishedTrack()`

See [Host controls pattern](/guides/server-api#host-controls-pattern) for complete endpoint examples.

## Webhooks: participant count on the join screen

You can use webhooks to track how many participants are in each room and display this on the join screen. dTelecom embeds the webhook URL in the access token — no dashboard configuration needed.

### 1. Add `WEBHOOK_URL` to `.env.local`

```bash
WEBHOOK_URL=https://your-public-url.com/api/webhook
```

During development, use [cloudflared](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/get-started/create-local-tunnel/) (no signup) to expose localhost:

```bash
brew install cloudflared
cloudflared tunnel --url http://localhost:3000
# Set WEBHOOK_URL to the printed URL + /api/webhook
```

### 2. Pass `webHookURL` in the token

Update your join route to include `webHookURL` in the `AccessToken` options:

```typescript title="app/api/join/route.ts" {5}
const at = new AccessToken(
  process.env.API_KEY!,
  process.env.API_SECRET!,
  { identity, name: identity, metadata, webHookURL: process.env.WEBHOOK_URL }
);
```

### 3. Webhook receiver

Create an endpoint that receives events and tracks counts in memory:

```typescript title="lib/participant-count.ts"
const g = globalThis as typeof globalThis & { __participantCounts?: Map<string, number> };
const counts = (g.__participantCounts ??= new Map<string, number>());

export function incrementRoom(name: string): void {
  counts.set(name, (counts.get(name) ?? 0) + 1);
}

export function decrementRoom(name: string): void {
  const n = (counts.get(name) ?? 0) - 1;
  n <= 0 ? counts.delete(name) : counts.set(name, n);
}

export function clearRoom(name: string): void {
  counts.delete(name);
}

export function getRoomCount(name: string): number {
  return counts.get(name) ?? 0;
}
```

```typescript title="app/api/webhook/route.ts"
import { WebhookReceiver } from '@dtelecom/server-sdk-js';
import { NextRequest, NextResponse } from 'next/server';
import { incrementRoom, decrementRoom, clearRoom } from '@/lib/participant-count';

const receiver = new WebhookReceiver(process.env.API_KEY!, process.env.API_SECRET!);

export async function POST(req: NextRequest) {
  const body = await req.text();
  const authToken = req.headers.get('Authorization') ?? '';
  const event = await receiver.receive(body, authToken);

  const roomName = event.room?.name;
  if (roomName) {
    if (event.event === 'participant_joined') incrementRoom(roomName);
    if (event.event === 'participant_left') decrementRoom(roomName);
    if (event.event === 'room_finished') clearRoom(roomName);
  }

  return NextResponse.json({ ok: true });
}
```

Webhooks are signed by the **SFU node** (not your app). `WebhookReceiver` automatically validates the node via the Solana registry. See [Webhooks](/guides/webhooks) for details.

### 4. Display count on the join page

Add a GET endpoint and fetch it from the home page:

```typescript title="app/api/room-count/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { getRoomCount } from '@/lib/participant-count';

export async function GET(req: NextRequest) {
  const room = req.nextUrl.searchParams.get('room');
  if (!room) return NextResponse.json({ error: 'room is required' }, { status: 400 });
  return NextResponse.json({ room, count: getRoomCount(room) });
}
```

On the home page, debounce-fetch the count as the user types a room name:

```tsx
const [participantCount, setParticipantCount] = useState<number | null>(null);

useEffect(() => {
  const trimmed = roomName.trim();
  if (!trimmed) { setParticipantCount(null); return; }
  const timer = setTimeout(() => {
    fetch(`/api/room-count?room=${encodeURIComponent(trimmed)}`)
      .then(r => r.json())
      .then(d => setParticipantCount(d.count ?? 0));
  }, 400);
  return () => clearTimeout(timer);
}, [roomName]);
```

## Next steps

- [Server APIs](/guides/server-api) — manage rooms and participants programmatically
- [Publishing media](/guides/room/publish) — fine-grained control over tracks
- [Webhooks](/guides/webhooks) — get notified when participants join/leave
